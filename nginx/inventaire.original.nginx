# PROJECT_ROOT, DOMAIN_NAME and PRERENDER_INSTANCE are set during nginx setup script

server_tokens off;

# Defining a log format arbitrary named "custom"
# doc: http://nginx.org/en/docs/http/ngx_http_log_module.html#log_format
log_format custom '$remote_addr - $remote_user "$request" $status'
                  ' | time: $request_time'
                  ' | length: req $request_length / res $body_bytes_sent'
                  ' | agent: $http_user_agent'
                  ' | referer: $http_referer'
                  ' | gzip ratio: $gzip_ratio';

# Access logs from journalctl
access_log syslog:server=unix:/dev/log custom;
error_log syslog:server=unix:/dev/log;

upstream inventaire {
    server 127.0.0.1:3006 fail_timeout=5s;
    server 127.0.0.1:3007 backup;
}

# Using error_page as a way to have a named location that can
# then be shared between several locations, see:
# https://serverfault.com/questions/908086/nginx-directly-send-from-location-to-another-named-location
# https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/#what-to-do-instead
# Contrary to what the documentation says, the HTTP verbs aren't all converted to GET
# http://nginx.org/en/docs/http/ngx_http_core_module.html#error_page
error_page 543 = @invserver;

server {
    listen 80;
    listen [::]:80;

    # Required to be able to run `certbot -w /var/www/html/`
    location /.well-known/ {
        root /var/www/html/;
    }

    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name www.DOMAIN_NAME;
    include /etc/nginx/snippets/ssl.conf;
    location / {
        include /etc/nginx/snippets/security_headers.conf;
        return 301 https://DOMAIN_NAME$request_uri;
    }
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name DOMAIN_NAME;

    # 'ssl_certificate' and 'ssl_certificate_key' will be added
    # by LetsEncrypt certbot

    include /etc/nginx/snippets/ssl.conf;

    client_max_body_size 25M;

    # As long as no secret/sensible data are passed in the body, the BREACH exploit on TLS+compression shouldn't be a concern. Right?
    # https://en.wikipedia.org/wiki/BREACH_(security_exploit)#Mitigation
    # http://security.stackexchange.com/questions/39925/breach-a-new-attack-against-http-what-can-be-done
    # It could be that it was solved by HTTP/2 \o/ https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2
    gzip on;
    gzip_types *;

    # On-The-Fly Image Resizer

    # URLs look like /img/users/300x1200/8185d4e039f52b4faa06a1c277133e9a8232551b
    # for locally hosted images
    # or /img/remote/300x1200/630022006?href=http%3A%2F%2Fescaped.url
    # for remote images, with 630022006 being the hash of the passed href
    # generated by [hashCode](https://github.com/inventaire/inventaire/blob/35b1e63/server/lib/utils/base.js#L69-L80)

    # The hack: I couldn't make the proxy_store work: it never hits the cache, but
    # it does put the resized images in /tmp/nginx/resize, so using a try_files
    # directive instead

    # Do not remove the (.*) capture group as it seems to be required by the try_files
    location ~ ^/img/(groups|users|entities|assets)/(.*) {
       include /etc/nginx/snippets/security_headers.conf;
       root /tmp/nginx/resize;
       default_type "image/jpeg";
       add_header Cache-Control "public, max-age=31536000, immutable";
       add_header X-File-Cache "hit";
       add_header Content-Security-Policy "sandbox";
       try_files $uri @invimg;
       limit_except GET {
           deny  all;
       }
    }

    # Same as above, but without the immutable
    location ~ ^/img/remote/(.*) {
       include /etc/nginx/snippets/security_headers.conf;
       root /tmp/nginx/resize;
       default_type "image/jpeg";
       add_header X-File-Cache "hit";
       add_header Content-Security-Policy "sandbox";
       try_files $uri @invimg;
       limit_except GET {
           deny  all;
       }
    }

    location ~ ^/img/(\d+)x(\d+)/(.*) {
        include /etc/nginx/snippets/security_headers.conf;
        return 404;
    }

    location @invimg {
      include /etc/nginx/snippets/security_headers.conf;
      default_type "image/jpeg";
      add_header X-File-Cache "miss";
      add_header Content-Security-Policy "sandbox";
      proxy_temp_path      /tmp/nginx/tmp;
      proxy_store          /tmp/nginx/resize/$uri;
      proxy_store_access   user:rw  group:rw  all:r;
      proxy_http_version 1.1;
      proxy_pass http://inventaire;
    }

    # following aliases made in order to respect the url structure
    # the server alone would follow: especially, mounting /static on /public
    root  PROJECT_ROOT/inventaire/client;
    location /public/ {
        include /etc/nginx/snippets/security_headers.conf;
        limit_except GET {
            deny  all;
        }
        gzip_static on;
        # Let resources that can't be cache busted
        # - such as opensearch.xml or robots.txt -
        # out of this caching policy
        if ($uri ~ "^/public/(dist|fonts)/" ) {
            include /etc/nginx/snippets/security_headers.conf;
            add_header Cache-Control "public, max-age=31536000, immutable";
            # All headers that aren't in the last block won't be taken in account
            # thus the need to have CORS headers here too
            add_header 'Access-Control-Allow-Origin' '*' always;
            add_header 'Access-Control-Allow-Methods' 'GET' always;
        }
    }

    # Pass the request to the node.js server
    # with some correct headers for proxy-awareness
    location /api {
        return 543;
    }

    location /.well-known/webfinger {
        return 543;
    }

    # Let the API server handle all but /public JSON and RSS requests
    location ~ "^/[^p].*\.(json|rss)$" {
        limit_except GET {
            deny  all;
        }
        return 543;
    }

    location @invserver {
        include /etc/nginx/snippets/security_headers.conf;
        # Let the server decide when CORS headers should be added
        proxy_set_header Host $http_host;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header Host $host;

        # Set a large value to let the API determine the appropriate
        # timeout per endpoint
        # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_read_timeout
        proxy_read_timeout 3600;
        proxy_redirect off;
        proxy_http_version 1.1;
        # Redirect Prerender API requests to their the alt server
        if ($remote_addr = PRERENDER_IP) {
            proxy_pass http://127.0.0.1:3007;
            break;
        }
        proxy_pass http://inventaire;
    }

    location = /favicon.ico {
        include /etc/nginx/snippets/security_headers.conf;
        try_files /public/$uri /public/images/$uri;
        expires 30d;
        add_header Cache-Control "public";
    }

    location = /robots.txt {
        include /etc/nginx/snippets/security_headers.conf;
        gzip_static on;
        try_files /public/$uri /$uri;
        expires 1d;
        add_header Cache-Control "public";
    }

    # Prevent exposing git folders such as /public/i18n/.git
    # For why this rule takes precedence over location /public/
    # see http://stackoverflow.com/a/34262192/3324977
    location ~ /\.git {
        deny all;
    }

    # Required to be able to run `certbot -w /var/www/html/`
    location /.well-known/ {
        include /etc/nginx/snippets/security_headers.conf;
        root /var/www/html/;
    }

    location / {
        include /etc/nginx/snippets/security_headers.conf;
        gzip_static on;
        try_files $uri @prerender;
        limit_except GET {
           deny all;
       }
    }

    # Dispatching requests between the JS-rendered client (for browsers)
    # or the prerendered version (for bots, curl and alikes)
    # To setup a Prerender server, see https://github.com/inventaire/prerender

    # Adapted from https://gist.github.com/thoop/8165802
    location @prerender {
        #proxy_set_header X-Prerender-Token YOUR_TOKEN;

        set $prerender 0;
        if ($http_user_agent ~* "bot|index|spider|crawl|facebookexternalhit|embedly|quora|outbrain|pinterest|vkShare|W3C_Validator|curl|wget|slurp|Discourse|Iframely") {
            set $prerender 1;
        }
        if ($args ~ "_escaped_fragment_") {
            set $prerender 1;
        }
        if ($args ~ "__nojs") {
            set $prerender 1;
        }
        if ($http_user_agent ~ "Prerender") {
            set $prerender 0;
        }
        if ($uri ~ "\.(js|css|xml|less|png|jpg|jpeg|gif|pdf|doc|txt|ico|rss|zip|mp3|rar|exe|wmv|doc|avi|ppt|mpg|mpeg|tif|wav|mov|psd|ai|xls|mp4|m4a|swf|dat|dmg|iso|flv|m4v|torrent|ttf|woff)") {
            set $prerender 0;
        }

        if ($prerender = 1) {
            #setting prerender as a variable forces DNS resolution since nginx caches IPs and doesnt play well with load balancing
            # set $prerender "92.222.76.42:3000";
            rewrite .* /$scheme://$host$request_uri? break;
            proxy_http_version 1.1;
            proxy_pass PRERENDER_INSTANCE;
        }
        if ($prerender = 0) {
            include /etc/nginx/snippets/security_headers.conf;

            add_header Report-To '{"max_age":10886400,"endpoints":[{"url":"https://inventaire.io/api/reports?action=csp-report"}]}'
            add_header Content-Security-Policy-Report-Only "default-src 'self' www.wikidata.org; child-src 'self' 'blob'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; font-src 'self'; img-src 'self' commons.wikimedia.org api.tiles.mapbox.com piwik.allmende.io data:; report-uri /api/reports?action=csp-report; report-to default"

            # index.html should always be fresh out of the server
            # time is negative => “Cache-Control: no-cache”
            # http://nginx.org/en/docs/http/ngx_http_headers_module.html
            # Those headers should be set here and not at "location /" as they would be ignored (cf http://serverfault.com/a/786248)
            expires -1;

            rewrite .* /public/index.html break;
        }
    }
}
